# Universal CI/CD Workflow Template for Educational Chatbot Microservices
# This template dynamically reads configuration from platform-requirements.yml
# Works for applications with any number of microservices and any configuration

name: Build and Deploy Educational Chatbot

on:
  push:
    branches: [ main, develop, staging ]  # Will be filtered by platform-requirements.yml
  pull_request:
    branches: [ main ]

# Add permissions for the GITHUB_TOKEN
permissions:
  contents: write          # Allow writing to repository (for updating Helm values)
  packages: write          # Allow pushing to container registry
  security-events: write   # Allow uploading security scan results
  actions: read           # Allow reading workflow artifacts
  checks: write           # Allow writing check results

env:
  # Default values - will be overridden by platform-requirements.yml
  REGISTRY: docker.io
  IMAGE_NAMESPACE: ""
  SOURCE_DIRECTORY: src/
  CONFIG_FILE: platform-requirements.yml

jobs:
  # Job 1: Read configuration from platform-requirements.yml
  config:
    runs-on: ubuntu-latest
    outputs:
      registry_host: ${{ steps.read-config.outputs.registry_host }}
      image_namespace: ${{ steps.read-config.outputs.image_namespace }}
      source_directory: ${{ steps.read-config.outputs.source_directory }}
      deployment_branches: ${{ steps.read-config.outputs.deployment_branches }}
      registry_username_secret: ${{ steps.read-config.outputs.registry_username_secret }}
      registry_password_secret: ${{ steps.read-config.outputs.registry_password_secret }}
      tagging_format: ${{ steps.read-config.outputs.tagging_format }}
      should_deploy: ${{ steps.check-deployment.outputs.should_deploy }}
      target_environment: ${{ steps.check-deployment.outputs.target_environment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install yq
      run: |
        sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        sudo chmod +x /usr/local/bin/yq
        
    - name: Read platform requirements
      id: read-config
      run: |
        # Read CI/CD configuration from platform-requirements.yml
        registry_host=$(yq e '.cicd.registry_host // "docker.io"' $CONFIG_FILE)
        image_namespace=$(yq e '.cicd.image_namespace // env(GITHUB_REPOSITORY_OWNER)' $CONFIG_FILE)
        source_directory=$(yq e '.cicd.source_directory // "src/"' $CONFIG_FILE)
        deployment_branches=$(yq e '.cicd.deployment_branches | @json' $CONFIG_FILE)
        registry_username_secret=$(yq e '.cicd.registry_credentials.username_secret // "DOCKERHUB_USERNAME"' $CONFIG_FILE)
        registry_password_secret=$(yq e '.cicd.registry_credentials.password_secret // "DOCKERHUB_TOKEN"' $CONFIG_FILE)
        tagging_format=$(yq e '.cicd.tagging_strategy.format // "{service}-{sha}"' $CONFIG_FILE)
        
        echo "registry_host=$registry_host" >> $GITHUB_OUTPUT
        echo "image_namespace=$image_namespace" >> $GITHUB_OUTPUT
        echo "source_directory=$source_directory" >> $GITHUB_OUTPUT
        echo "deployment_branches=$deployment_branches" >> $GITHUB_OUTPUT
        echo "registry_username_secret=$registry_username_secret" >> $GITHUB_OUTPUT
        echo "registry_password_secret=$registry_password_secret" >> $GITHUB_OUTPUT
        echo "tagging_format=$tagging_format" >> $GITHUB_OUTPUT
        
        echo "Configuration loaded:"
        echo "  Registry: $registry_host"
        echo "  Namespace: $image_namespace"
        echo "  Source Dir: $source_directory"
        echo "  Deployment Branches: $deployment_branches"
        
    - name: Check deployment conditions
      id: check-deployment
      run: |
        # Check if current branch should trigger deployment
        current_branch=${GITHUB_REF#refs/heads/}
        deployment_branches='${{ steps.read-config.outputs.deployment_branches }}'
        
        should_deploy="false"
        target_environment="none"
        
        if echo "$deployment_branches" | jq -r '.[]' | grep -q "^$current_branch$"; then
          should_deploy="true"
          # Get environment mapping
          target_environment=$(yq e ".cicd.environment_mapping.\"$current_branch\" // \"$current_branch\"" $CONFIG_FILE)
        fi
        
        echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
        echo "target_environment=$target_environment" >> $GITHUB_OUTPUT
        echo "Branch '$current_branch' -> Deploy: $should_deploy, Environment: $target_environment"

  # Job 2: Discover microservices dynamically
  discover:
    needs: config
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.find-services.outputs.services }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Find microservices
      id: find-services
      run: |
        source_dir="${{ needs.config.outputs.source_directory }}"
        echo "Scanning for Dockerfiles in: $source_dir"
        
        services="[]"
        
        # Find all directories with Dockerfiles in the source directory
        for dockerfile in $(find "$source_dir" -name "Dockerfile" -type f); do
          # Get the directory name (service name)
          service_dir=$(dirname "$dockerfile")
          service_name=$(basename "$service_dir")
          
          echo "Found service: $service_name (Dockerfile: $dockerfile)"
          
          # Build the service JSON object with repository root as context
          service_json=$(jq -n \
            --arg name "$service_name" \
            --arg dockerfile "./$dockerfile" \
            --arg context "." \
            '{name: $name, dockerfile: $dockerfile, context: $context}')
          
          # Add to services array
          services=$(echo "$services" | jq --argjson service "$service_json" '. + [$service]')
        done
        
        # Compact the JSON to avoid formatting issues with newlines
        services_compact=$(echo "$services" | jq -c .)
        
        # Use delimiter for multiline output
        {
          echo "services<<EOF"
          echo "$services_compact"
          echo "EOF"
        } >> $GITHUB_OUTPUT
        
        echo "Discovered services:"
        echo "$services" | jq .

  # Job 3: Build, scan, and push Docker images for each microservice
  build:
    needs: [config, discover]
    runs-on: ubuntu-latest
    if: needs.discover.outputs.services != '[]'
    strategy:
      matrix:
        service: ${{ fromJson(needs.discover.outputs.services) }}
    steps:
    - name: Debug matrix configuration
      run: |
        echo "Service Name: ${{ matrix.service.name }}"
        echo "Dockerfile: ${{ matrix.service.dockerfile }}"
        echo "Context: ${{ matrix.service.context }}"
        echo "Services JSON: ${{ needs.discover.outputs.services }}"
        
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Debug registry configuration
      run: |
        echo "Registry host: ${{ needs.config.outputs.registry_host }}"
        echo "Image namespace: ${{ needs.config.outputs.image_namespace }}"
        echo "Username secret name: ${{ needs.config.outputs.registry_username_secret }}"
        echo "Password secret name: ${{ needs.config.outputs.registry_password_secret }}"
        
    - name: Log in to container registry
      uses: docker/login-action@v3
      with:
        registry: ${{ needs.config.outputs.registry_host }}
        username: ${{ secrets[needs.config.outputs.registry_username_secret] }}
        password: ${{ secrets[needs.config.outputs.registry_password_secret] }}
        
    - name: Verify Docker login
      run: |
        echo "Testing Docker Hub connection..."
        docker info
        docker version
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        # Set a single, static repository name
        images: ${{ needs.config.outputs.registry_host }}/${{ needs.config.outputs.image_namespace }}/educational-chatbot
        # Add the service name as a prefix to all tags (removed latest tag)
        tags: |
          type=raw,value=${{ matrix.service.name }}-${{ github.ref_name }}-${{ github.sha }}
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ${{ matrix.service.context }}
        file: ${{ matrix.service.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        outputs: type=registry
        
    - name: Debug build outputs
      run: |
        echo "Build completed for service: ${{ matrix.service.name }}"
        echo "Image tags: ${{ steps.meta.outputs.tags }}"
        echo "Image digest: ${{ steps.meta.outputs.digest }}"
        echo "Expected image: ${{ needs.config.outputs.registry_host }}/${{ needs.config.outputs.image_namespace }}/educational-chatbot"
        echo "Service-specific tags: ${{ matrix.service.name }}-${{ github.ref_name }}-${{ github.sha }}"
        
    # === SECURITY SCANNING STEPS (moved from separate job) ===
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        # Scan the image using the exact tag that was just built
        # Trivy will find this in the runner's local Docker cache
        image-ref: ${{ steps.meta.outputs.tags }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.service.name }}.sarif'
        timeout: '10m'  # Increase timeout to 10 minutes
        scanners: 'vuln'  # Only scan for vulnerabilities to speed up
        severity: 'HIGH,CRITICAL'  # Only fail on high/critical issues
        
    - name: Fallback: Quick Trivy scan (vulnerabilities only)
      if: failure()
      continue-on-error: true
      run: |
        echo "Full scan failed, attempting quick vulnerability-only scan..."
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy:latest image \
          --timeout 5m \
          --scanners vuln \
          --severity HIGH,CRITICAL \
          ${{ steps.meta.outputs.tags }} || echo "Quick scan also failed"
        
    - name: Check if SARIF file was created
      id: check-sarif
      run: |
        if [ -f "trivy-results-${{ matrix.service.name }}.sarif" ]; then
          echo "sarif_exists=true" >> $GITHUB_OUTPUT
          echo "✅ SARIF file created successfully"
        else
          echo "sarif_exists=false" >> $GITHUB_OUTPUT
          echo "❌ SARIF file not found (scan may have failed or timed out)"
        fi
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: steps.check-sarif.outputs.sarif_exists == 'true'
      with:
        sarif_file: 'trivy-results-${{ matrix.service.name }}.sarif'
        
    - name: Output image details
      run: |
        echo "Built and pushed image for service: ${{ matrix.service.name }}"
        echo "Image tags: ${{ steps.meta.outputs.tags }}"
        echo "Image digest: ${{ steps.meta.outputs.digest }}"

  # NOTE: Deploy job removed - ArgoCD Image Updater handles deployment automation
  # Images are built and pushed to Docker registry, ArgoCD Image Updater will:
  # 1. Detect new SHA-based image tags
  # 2. Update Helm values automatically
  # 3. Commit changes to repository
  # 4. Trigger ArgoCD sync

  # Job 4: Notification and summary
  notify:
    needs: [config, discover, build]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Build Summary
      run: |
        echo "## 🤖 Educational Chatbot CI/CD Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ✅ Build & Push Status" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Images**: Built and pushed to Docker registry" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment**: ArgoCD Image Updater will auto-detect and deploy" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔨 Built Services" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.discover.outputs.services }}" != "[]" ]; then
          echo '${{ needs.discover.outputs.services }}' | jq -r '.[] | "- **" + .name + "** (from `" + .dockerfile + "`)"' >> $GITHUB_STEP_SUMMARY
        else
          echo "No services found to build." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📊 Job Status" >> $GITHUB_STEP_SUMMARY
        echo "- **Config**: ${{ needs.config.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Discovery**: ${{ needs.discover.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build & Security**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🚀 Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "ArgoCD Image Updater will automatically:" >> $GITHUB_STEP_SUMMARY
        echo "1. Detect new SHA-based image tags" >> $GITHUB_STEP_SUMMARY
        echo "2. Update Helm values with new tags" >> $GITHUB_STEP_SUMMARY
        echo "3. Commit changes to repository" >> $GITHUB_STEP_SUMMARY
        echo "4. Trigger ArgoCD application sync" >> $GITHUB_STEP_SUMMARY
